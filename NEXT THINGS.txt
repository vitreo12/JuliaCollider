Data should be a struct (instead of mutable struct). This way, I can't have
a finalizer, and I would need three more
arrays like gc_array and in ~Julia. Then, I would store the pointers to ugen_object,
ugen_destructor_function and ugen_destructor_instance. I would then call the DESTRUCTOR
with jl_invoke.... right before the GC call. 

0) ADD VARIABLES UNROLLING IN DESTRUCTOR

1) Have a class for GC calls on a third thread

2) Add inputs/outputs check after recompilation. Prompt to user if anything wrong.  V

3) Add Buffer allocation inside JuliaCollider.jl  V

4) Add Buffer pointer as argument (and relative error checking) V

5) Add a counter for number of times that compiler has been run. Run GC every 5 calls.

6) Finish JuliaDef SC interface (recompile, autowatch, etc...)

7) Check better the code for JuliaObjectsArray. It might be having a ** instead of a *, allocating memory from different positions,
   giving a maximum of 10 pools (1000 objects). New pools will be allocated when ID > total_entries.

8) Use stack allocation for everything possible (jl_value_t* args[nargs], args[i]...)

9) Implement JuliaDefProxy

10) DOCUMENTATION AND EXAMPLES
